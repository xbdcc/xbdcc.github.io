
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Android TV按键焦点原理浅谈 | Carlos</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Carlos">
    

    
    <meta name="description" content="本篇主要阅读Android源码讲解TV的按键事件分发原理和焦点查找原理，源码基于Android9.0，首先思考几个问题:  当遥控器按下一个按键时按键事件是如何一步一步分发处理的 为什么有的设备长按遥控器第一次会先onKeyDown、onKeyUp，之后才是正常的一直onKeyDown直到松手才onKeyUp 当给View设置setOnKeyListener时，会先走View的onKeyDown回">
<meta property="og:type" content="article">
<meta property="og:title" content="Android TV按键焦点原理浅谈">
<meta property="og:url" content="http://yoursite.com/2022/06/22/Android-TV%E6%8C%89%E9%94%AE%E7%84%A6%E7%82%B9%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/index.html">
<meta property="og:site_name" content="Carlos">
<meta property="og:description" content="本篇主要阅读Android源码讲解TV的按键事件分发原理和焦点查找原理，源码基于Android9.0，首先思考几个问题:  当遥控器按下一个按键时按键事件是如何一步一步分发处理的 为什么有的设备长按遥控器第一次会先onKeyDown、onKeyUp，之后才是正常的一直onKeyDown直到松手才onKeyUp 当给View设置setOnKeyListener时，会先走View的onKeyDown回">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-06-22T11:13:55.000Z">
<meta property="article:modified_time" content="2022-06-22T11:18:09.000Z">
<meta property="article:author" content="Carlos">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="原理">
<meta name="twitter:card" content="summary">

    
    <link rel="alternative" href="/atom.xml" title="Carlos" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/xiaobudian.jpg">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">



    <meta name="baidu-site-verification" content="ZXZX44IZdr" />


</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/xiaobudian.jpg" alt="Carlos" title="Carlos"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Carlos">Carlos</a></h1>
				<h2 class="blog-motto">没有什么到不了的地方，没有什么上不了的天堂，相信就有力量。不骄不躁，不卑不亢，不屈不挠。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/me">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
						
					</li>
					
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/06/22/Android-TV按键焦点原理浅谈/" title="Android TV按键焦点原理浅谈" itemprop="url">Android TV按键焦点原理浅谈</a>
  </h1>
  <p class="article-author">By
       
		<a href="/me" title="Carlos" target="_blank" itemprop="author">Carlos</a>
		
  <p class="article-time">
    <time datetime="2022-06-22T11:13:55.000Z" itemprop="datePublished"> 发表于 2022-06-22</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E5%85%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">一、按键事件入口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">二、按键事件分发流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%84%A6%E7%82%B9%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">三、焦点导航流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#findFocus"><span class="toc-number">3.1.</span> <span class="toc-text">findFocus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#focusSearch"><span class="toc-number">3.2.</span> <span class="toc-text">focusSearch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findNextUserSpecifiedFocus"><span class="toc-number">3.3.</span> <span class="toc-text">findNextUserSpecifiedFocus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findNextFocus"><span class="toc-number">3.4.</span> <span class="toc-text">findNextFocus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isBetterCandidate"><span class="toc-number">3.5.</span> <span class="toc-text">isBetterCandidate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#requestFocus"><span class="toc-number">3.6.</span> <span class="toc-text">requestFocus</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">4.</span> <span class="toc-text">参考链接</span></a></li></ol>
		
		</div>
		
		<p>本篇主要阅读<code>Android</code>源码讲解<code>TV</code>的按键事件分发原理和焦点查找原理，源码基于<code>Android9.0</code>，首先思考几个问题:</p>
<ul>
<li>当遥控器按下一个按键时按键事件是如何一步一步分发处理的</li>
<li>为什么有的设备长按遥控器第一次会先<code>onKeyDown</code>、<code>onKeyUp</code>，之后才是正常的一直<code>onKeyDown</code>直到松手才<code>onKeyUp</code></li>
<li>当给<code>View</code>设置<code>setOnKeyListener</code>时，会先走<code>View</code>的<code>onKeyDown</code>回调还是<code>OnKeyListener</code>回调</li>
<li><code>Activity</code>的<code>onBackPressed</code>方法什么情况下会调用</li>
<li>当按键按下方向键时焦点时如果未控制下一个获取焦点的时候，系统是如何知道该让哪一个控件获取焦点的</li>
</ul>
<p>带着这些问题，我们一起来撸<code>Android</code>源码吧！了解了系统是如何处理的有便于我们解决<code>TV</code>上一些按键和焦点的问题。</p>
<h3 id="一、按键事件入口"><a href="#一、按键事件入口" class="headerlink" title="一、按键事件入口"></a>一、按键事件入口</h3><p>首先我们看下按键事件的入口<code>ViewRootImpl</code>类中的<code>ViewPostImeInputStage</code>内部类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Delivers post-ime input events to the view hierarchy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ViewPostImeInputStage</span> <span class="keyword">extends</span> <span class="title class_">InputStage</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ViewPostImeInputStage</span><span class="params">(InputStage next)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">onProcess</span><span class="params">(QueuedInputEvent q)</span> &#123;</span><br><span class="line">      	<span class="comment">// 1.判断为按键事件则执行processKeyEvent方法</span></span><br><span class="line">        <span class="keyword">if</span> (q.mEvent <span class="keyword">instanceof</span> KeyEvent) &#123;</span><br><span class="line">            <span class="keyword">return</span> processKeyEvent(q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">source</span> <span class="operator">=</span> q.mEvent.getSource();</span><br><span class="line">          	<span class="comment">// 2.判断为触摸事件则执行processPointerEvent方法</span></span><br><span class="line">            <span class="keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_POINTER) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> processPointerEvent(q);</span><br><span class="line">            <span class="comment">// 3.判断为轨迹球事件则执行processTrackballEvent方法</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((source &amp; InputDevice.SOURCE_CLASS_TRACKBALL) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> processTrackballEvent(q);</span><br><span class="line">            <span class="comment">// 4.判断为运动事件则执行processGenericMotionEvent方法</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> processGenericMotionEvent(q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到注释1,2,3,4分别判断不同事件执行不同方法，本篇主要讨论的TV焦点事件，主要看下<code>processKeyEvent</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">processKeyEvent</span><span class="params">(QueuedInputEvent q)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">KeyEvent</span> <span class="variable">event</span> <span class="operator">=</span> (KeyEvent)q.mEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mUnhandledKeyManager.preViewDispatch(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 1.分发按键，如果有消费返回true不继续往下执行</span></span><br><span class="line">    <span class="comment">// Deliver the key to the view hierarchy.</span></span><br><span class="line">    <span class="keyword">if</span> (mView.dispatchKeyEvent(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldDropInputEvent(q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_NOT_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This dispatch is for windows that don&#x27;t have a Window.Callback. Otherwise,</span></span><br><span class="line">    <span class="comment">// the Window.Callback usually will have already called this (see</span></span><br><span class="line">    <span class="comment">// DecorView.superDispatchKeyEvent) leaving this call a no-op.</span></span><br><span class="line">    <span class="keyword">if</span> (mUnhandledKeyManager.dispatch(mView, event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">groupNavigationDirection</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_DOWN</span><br><span class="line">            &amp;&amp; event.getKeyCode() == KeyEvent.KEYCODE_TAB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (KeyEvent.metaStateHasModifiers(event.getMetaState(), KeyEvent.META_META_ON)) &#123;</span><br><span class="line">            groupNavigationDirection = View.FOCUS_FORWARD;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (KeyEvent.metaStateHasModifiers(event.getMetaState(),</span><br><span class="line">                KeyEvent.META_META_ON | KeyEvent.META_SHIFT_ON)) &#123;</span><br><span class="line">            groupNavigationDirection = View.FOCUS_BACKWARD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a modifier is held, try to interpret the key as a shortcut.</span></span><br><span class="line">    <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_DOWN</span><br><span class="line">            &amp;&amp; !KeyEvent.metaStateHasNoModifiers(event.getMetaState())</span><br><span class="line">            &amp;&amp; event.getRepeatCount() == <span class="number">0</span></span><br><span class="line">            &amp;&amp; !KeyEvent.isModifierKey(event.getKeyCode())</span><br><span class="line">            &amp;&amp; groupNavigationDirection == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView.dispatchKeyShortcutEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shouldDropInputEvent(q)) &#123;</span><br><span class="line">            <span class="keyword">return</span> FINISH_NOT_HANDLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Apply the fallback event policy.</span></span><br><span class="line">    <span class="keyword">if</span> (mFallbackEventHandler.dispatchKeyEvent(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldDropInputEvent(q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_NOT_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle automatic focus changes.</span></span><br><span class="line">    <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (groupNavigationDirection != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (performKeyboardGroupNavigation(groupNavigationDirection)) &#123;</span><br><span class="line">                <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         		<span class="comment">// 2.如果按下按键则执行焦点导航逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (performFocusNavigation(event)) &#123;</span><br><span class="line">                <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FORWARD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二、按键事件分发流程"><a href="#二、按键事件分发流程" class="headerlink" title="二、按键事件分发流程"></a>二、按键事件分发流程</h3><p>可以看到在该方法中执行了<code>mView.dispatchKeyEvent</code>方法，这里的<code>View</code>其实是<code>DecorView</code>，接着看下该方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">keyCode</span> <span class="operator">=</span> event.getKeyCode();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">isDown</span> <span class="operator">=</span> action == KeyEvent.ACTION_DOWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.如果是第一次按下则处理panel的快捷键</span></span><br><span class="line">    <span class="keyword">if</span> (isDown &amp;&amp; (event.getRepeatCount() == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// First handle chording of panel key: if a panel key is held</span></span><br><span class="line">        <span class="comment">// but not released, try to execute a shortcut in it.</span></span><br><span class="line">        <span class="keyword">if</span> ((mWindow.mPanelChordingKey &gt; <span class="number">0</span>) &amp;&amp; (mWindow.mPanelChordingKey != keyCode)) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> dispatchKeyShortcutEvent(event);</span><br><span class="line">            <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a panel is open, perform a shortcut on it without the</span></span><br><span class="line">        <span class="comment">// chorded panel key</span></span><br><span class="line">        <span class="keyword">if</span> ((mWindow.mPreparedPanel != <span class="literal">null</span>) &amp;&amp; mWindow.mPreparedPanel.isOpen) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWindow.performPanelShortcut(mWindow.mPreparedPanel, keyCode, event, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> 		<span class="comment">// 2.当Window没destroy且其Callback非空的话，交给其Callback处理</span></span><br><span class="line">    <span class="keyword">if</span> (!mWindow.isDestroyed()) &#123;</span><br><span class="line">        <span class="keyword">final</span> Window.<span class="type">Callback</span> <span class="variable">cb</span> <span class="operator">=</span> mWindow.getCallback();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> cb != <span class="literal">null</span> &amp;&amp; mFeatureId &lt; <span class="number">0</span> ? cb.dispatchKeyEvent(event)</span><br><span class="line">                : <span class="built_in">super</span>.dispatchKeyEvent(event);</span><br><span class="line">        <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 3.如果上面还没处理，则分发到PhoneWindow到onKeyDown、onKeyUp事件处理</span></span><br><span class="line">    <span class="keyword">return</span> isDown ? mWindow.onKeyDown(mFeatureId, event.getKeyCode(), event)</span><br><span class="line">            : mWindow.onKeyUp(mFeatureId, event.getKeyCode(), event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面首先判断了如果是第一次按下则处理panel的快捷键，如果处理了则不往下走，否则继续判断当窗口未销毁且回调非空则回调处理，如果处理了则不往下走，否则让<code>PhoneWindow</code>对应的<code>onKeyDown</code>，<code>onKeyUp</code>方法来处理。</p>
<p>接下来我们按照这个派发顺序依次来看看相关方法的实现，这里先看看<code>Activity</code>的<code>dispatchKeyEvent</code>实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called to process key events.  You can override this to intercept all</span></span><br><span class="line"><span class="comment"> * key events before they are dispatched to the window.  Be sure to call</span></span><br><span class="line"><span class="comment"> * this implementation for key events that should be handled normally.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event The key event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean Return true if this event was consumed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> &#123;</span><br><span class="line">    onUserInteraction();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let action bars open menus in response to the menu key prioritized over</span></span><br><span class="line">    <span class="comment">// the window handling it</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">keyCode</span> <span class="operator">=</span> event.getKeyCode();</span><br><span class="line">    <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp;</span><br><span class="line">            mActionBar != <span class="literal">null</span> &amp;&amp; mActionBar.onMenuKeyEvent(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Window</span> <span class="variable">win</span> <span class="operator">=</span> getWindow();</span><br><span class="line">    <span class="comment">// 1.从这里事件的处理交给了与之相关的window对象，实质是派发到了view层次结构</span></span><br><span class="line">    <span class="keyword">if</span> (win.superDispatchKeyEvent(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">View</span> <span class="variable">decor</span> <span class="operator">=</span> mDecor;</span><br><span class="line">    <span class="keyword">if</span> (decor == <span class="literal">null</span>) decor = win.getDecorView();</span><br><span class="line">    <span class="comment">// 2.如果view层次结构没处理则交给KeyEvent本身的dispatch方法，Activity的各种回调方法会被触发</span></span><br><span class="line">    <span class="keyword">return</span> event.dispatch(<span class="built_in">this</span>, decor != <span class="literal">null</span></span><br><span class="line">            ? decor.getKeyDispatcherState() : <span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看第1点<code>superDispatchKeyEvent</code>方法，可以看到该方法为一个抽象方法，而它的实现是实现它的子类<code>PhoneWindow</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchKeyEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法又回调用<code>DecorView</code>中的<code>superDispatchKeyEvent</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// Give priority to closing action modes if applicable.</span></span><br><span class="line">    <span class="keyword">if</span> (event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">        <span class="comment">// Back cancels action modes first.</span></span><br><span class="line">        <span class="keyword">if</span> (mPrimaryActionMode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                mPrimaryActionMode.finish();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 1.如果ViewGroup的dispatchKeyEvent方法消费掉了，返回true不走下面</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">super</span>.dispatchKeyEvent(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 2.如果ViewRootImpl不为空且被ViewRootImpl的dispatchUnhandledKeyEvent方法消费了，则返回true</span></span><br><span class="line">    <span class="keyword">return</span> (getViewRootImpl() != <span class="literal">null</span>) &amp;&amp; getViewRootImpl().dispatchUnhandledKeyEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，再来看下<code>ViewGroup</code>的<code>dispatchKeyEvent</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="literal">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onKeyEvent(event, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS))</span><br><span class="line">            == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) &#123;</span><br><span class="line">      	<span class="comment">// 1.如果ViewGroup当前是获焦状态或者有边界，分发给View处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">super</span>.dispatchKeyEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFocused != <span class="literal">null</span> &amp;&amp; (mFocused.mPrivateFlags &amp; PFLAG_HAS_BOUNDS)</span><br><span class="line">            == PFLAG_HAS_BOUNDS) &#123;</span><br><span class="line">     		<span class="comment">// 2.如果ViewGroup中有获取焦点的View并且ViewGroup有边界，则交给mFocused处理</span></span><br><span class="line">        <span class="keyword">if</span> (mFocused.dispatchKeyEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="literal">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看下<code>View</code>的<code>dispatchKeyEvent</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch a key event to the next view on the focus path. This path runs</span></span><br><span class="line"><span class="comment"> * from the top of the view tree down to the currently focused view. If this</span></span><br><span class="line"><span class="comment"> * view has focus, it will dispatch to itself. Otherwise it will dispatch</span></span><br><span class="line"><span class="comment"> * the next node down the focus path. This method also fires any key</span></span><br><span class="line"><span class="comment"> * listeners.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event The key event to be dispatched.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if the event was handled, false otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="literal">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onKeyEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give any attached key listener a first crack at the event.</span></span><br><span class="line">    <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">    <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">  	<span class="comment">// 1.如果OnKeyListener非空且view是ENABLED状态，则监听器优先触发</span></span><br><span class="line">    <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnKeyListener != <span class="literal">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">            &amp;&amp; li.mOnKeyListener.onKey(<span class="built_in">this</span>, event.getKeyCode(), event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 2.调用KeyEvent的dispatch方法，并将view对象本身作为参数传递进去</span></span><br><span class="line">    <span class="keyword">if</span> (event.dispatch(<span class="built_in">this</span>, mAttachInfo != <span class="literal">null</span></span><br><span class="line">            ? mAttachInfo.mKeyDispatchState : <span class="literal">null</span>, <span class="built_in">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="literal">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(event, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要是判断如果有给<code>View</code>设置<code>OnKeyListener</code>事件且<code>View</code>为可用状态，则优先处理监听事件，其次调用<code>KeyEvent</code>的<code>dispatch</code>方法，接下来我们看下该方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Deliver this key event to a &#123;<span class="doctag">@link</span> Callback&#125; interface.  If this is</span></span><br><span class="line"><span class="comment"> * an ACTION_MULTIPLE event and it is not handled, then an attempt will</span></span><br><span class="line"><span class="comment"> * be made to deliver a single normal event.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> receiver The Callback that will be given the event.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> state State information retained across events.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target The target of the dispatch, for use in tracking.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The return value from the Callback method that was called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">dispatch</span><span class="params">(Callback receiver, DispatcherState state,</span></span><br><span class="line"><span class="params">        Object target)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (mAction) &#123;</span><br><span class="line">        <span class="keyword">case</span> ACTION_DOWN: &#123;</span><br><span class="line">            mFlags &amp;= ~FLAG_START_TRACKING;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Key down to &quot;</span> + target + <span class="string">&quot; in &quot;</span> + state</span><br><span class="line">                    + <span class="string">&quot;: &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> receiver.onKeyDown(mKeyCode, <span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (state != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res &amp;&amp; mRepeatCount == <span class="number">0</span> &amp;&amp; (mFlags&amp;FLAG_START_TRACKING) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;  Start tracking!&quot;</span>);</span><br><span class="line">                    state.startTracking(<span class="built_in">this</span>, target);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isLongPress() &amp;&amp; state.isTracking(<span class="built_in">this</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (receiver.onKeyLongPress(mKeyCode, <span class="built_in">this</span>)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;  Clear from long press!&quot;</span>);</span><br><span class="line">                            state.performedLongPress(<span class="built_in">this</span>);</span><br><span class="line">                            res = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (AbstractMethodError e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> ACTION_UP:</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Key up to &quot;</span> + target + <span class="string">&quot; in &quot;</span> + state</span><br><span class="line">                    + <span class="string">&quot;: &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (state != <span class="literal">null</span>) &#123;</span><br><span class="line">                state.handleUpEvent(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> receiver.onKeyUp(mKeyCode, <span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">case</span> ACTION_MULTIPLE:</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> mRepeatCount;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> mKeyCode;</span><br><span class="line">            <span class="keyword">if</span> (receiver.onKeyMultiple(code, count, <span class="built_in">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (code != KeyEvent.KEYCODE_UNKNOWN) &#123;</span><br><span class="line">                mAction = ACTION_DOWN;</span><br><span class="line">                mRepeatCount = <span class="number">0</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">handled</span> <span class="operator">=</span> receiver.onKeyDown(code, <span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">                    mAction = ACTION_UP;</span><br><span class="line">                    receiver.onKeyUp(code, <span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mAction = ACTION_MULTIPLE;</span><br><span class="line">                mRepeatCount = count;</span><br><span class="line">                <span class="keyword">return</span> handled;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要处理了按下、弹起事件，其中按下如果<code>mRepeatCount</code>重复次数大于0判断为长按，则执行长按事件。</p>
<p>我们继续看下<code>View</code>的<code>onKeyDown</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default implementation of &#123;<span class="doctag">@link</span> KeyEvent.Callback#onKeyDown(int, KeyEvent)</span></span><br><span class="line"><span class="comment"> * KeyEvent.Callback.onKeyDown()&#125;: perform press of the view</span></span><br><span class="line"><span class="comment"> * when &#123;<span class="doctag">@link</span> KeyEvent#KEYCODE_DPAD_CENTER&#125; or &#123;<span class="doctag">@link</span> KeyEvent#KEYCODE_ENTER&#125;</span></span><br><span class="line"><span class="comment"> * is released, if the view is enabled and clickable.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Key presses in software keyboards will generally NOT trigger this</span></span><br><span class="line"><span class="comment"> * listener, although some may elect to do so in some situations. Do not</span></span><br><span class="line"><span class="comment"> * rely on this to catch software key presses.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyCode a key code that represents the button pressed, from</span></span><br><span class="line"><span class="comment"> *                &#123;<span class="doctag">@link</span> android.view.KeyEvent&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> event the KeyEvent object that defines the button action</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onKeyDown</span><span class="params">(<span class="type">int</span> keyCode, KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (KeyEvent.isConfirmKey(keyCode)) &#123;</span><br><span class="line">      	<span class="comment">// 1.如果View为不可用状态，则返回true</span></span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 2.如果事件重复为0次并且View是可点击的或者可长按的，则设置按下View正中间坐标，检查长按</span></span><br><span class="line">        <span class="keyword">if</span> (event.getRepeatCount() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Long clickable items don&#x27;t necessarily have to be clickable.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">clickable</span> <span class="operator">=</span> (mViewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                    || (mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE;</span><br><span class="line">            <span class="keyword">if</span> (clickable || (mViewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">                <span class="comment">// For the purposes of menu anchoring and drawable hotspots,</span></span><br><span class="line">                <span class="comment">// key events are considered to be at the center of the view.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> getWidth() / <span class="number">2f</span>;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">float</span> <span class="variable">y</span> <span class="operator">=</span> getHeight() / <span class="number">2f</span>;</span><br><span class="line">                <span class="keyword">if</span> (clickable) &#123;</span><br><span class="line">                    setPressed(<span class="literal">true</span>, x, y);</span><br><span class="line">                &#125;</span><br><span class="line">                checkForLongClick(<span class="number">0</span>, x, y);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按下事件判断了如果为确认相关的按键才到下一步处理，判断点击或长按条件满足，执行按下<code>View</code>正中心坐标，然后执行<code>checkForLongClick</code>检查长按方法，看下该方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkForLongClick</span><span class="params">(<span class="type">int</span> delayOffset, <span class="type">float</span> x, <span class="type">float</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE || (mViewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">        mHasPerformedLongPress = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingCheckForLongPress == <span class="literal">null</span>) &#123;</span><br><span class="line">            mPendingCheckForLongPress = <span class="keyword">new</span> <span class="title class_">CheckForLongPress</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingCheckForLongPress.setAnchor(x, y);</span><br><span class="line">        mPendingCheckForLongPress.rememberWindowAttachCount();</span><br><span class="line">        mPendingCheckForLongPress.rememberPressedState();</span><br><span class="line">      	<span class="comment">// 1.延迟执行mPendingCheckForLongPress长按Runnable,</span></span><br><span class="line">        postDelayed(mPendingCheckForLongPress,</span><br><span class="line">                ViewConfiguration.getLongPressTimeout() - delayOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们经常会遇到电视按遥控器时长按会执行一次<code>onKeyDown</code>、<code>onKeyUp</code>，之后才是一直<code>onKeyDown</code>，松开后才执行<code>onKeyUp</code>，原因就在于这个检查长按方法是延迟的。<code>delayOffset</code>传进来的是0，所以延迟时间为<code>ViewConfiguration.getLongPressTimeout()</code>，即该类中定义的<code>DEFAULT_LONG_PRESS_TIMEOUT</code>常量。</p>
<p>同样的如果是触摸屏，可以看下<code>View</code>类中的<code>onTouchEvent</code>方法在按下操作的时候会开启<code>CheckForTap</code>线程检查是否是长按，该线程同样是延迟的，时间为<code>ViewConfiguration.getTapTimeout()</code>，即该类中的<code>TAP_TIMEOUT</code>常量，知道了这个你就知道如果写脚本或插件模拟长按应该间隔多长时间了，是不是一下你的模拟长按插件速度又可以更加准确快速的实现了。</p>
<p>不同版本系统定义的延迟时间有可能不一样，比如Google<code>API 28</code>的<code>DEFAULT_LONG_PRESS_TIMEOUT</code>是500，<code>TAP_TIMEOUT</code>是100，而<code>API 30</code>的<code>DEFAULT_LONG_PRESS_TIMEOUT</code>是400，<code>TAP_TIMEOUT</code>也是100。</p>
<p>接下来再看下<code>Activity</code>的<code>onKeyDown</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when a key was pressed down and not handled by any of the views</span></span><br><span class="line"><span class="comment"> * inside of the activity. So, for example, key presses while the cursor</span></span><br><span class="line"><span class="comment"> * is inside a TextView will not trigger the event (unless it is a navigation</span></span><br><span class="line"><span class="comment"> * to another object) because TextView handles its own key presses.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the focused view didn&#x27;t want this event, this method is called.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation takes care of &#123;<span class="doctag">@link</span> KeyEvent#KEYCODE_BACK&#125;</span></span><br><span class="line"><span class="comment"> * by calling &#123;<span class="doctag">@link</span> #onBackPressed()&#125;, though the behavior varies based</span></span><br><span class="line"><span class="comment"> * on the application compatibility mode: for</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> android.os.Build.VERSION_CODES#ECLAIR&#125; or later applications,</span></span><br><span class="line"><span class="comment"> * it will set up the dispatch to call &#123;<span class="doctag">@link</span> #onKeyUp&#125; where the action</span></span><br><span class="line"><span class="comment"> * will be performed; for earlier applications, it will perform the</span></span><br><span class="line"><span class="comment"> * action immediately in on-down, as those versions of the platform</span></span><br><span class="line"><span class="comment"> * behaved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Other additional default key handling may be performed</span></span><br><span class="line"><span class="comment"> * if configured with &#123;<span class="doctag">@link</span> #setDefaultKeyMode&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Return &lt;code&gt;true&lt;/code&gt; to prevent this event from being propagated</span></span><br><span class="line"><span class="comment"> * further, or &lt;code&gt;false&lt;/code&gt; to indicate that you have not handled</span></span><br><span class="line"><span class="comment"> * this event and it should continue to be propagated.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #onKeyUp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> android.view.KeyEvent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onKeyDown</span><span class="params">(<span class="type">int</span> keyCode, KeyEvent event)</span>  &#123;</span><br><span class="line">  	<span class="comment">// 1.当按下返回键时调用onBackPressed，如果没走检查下是不是重写了onKeyDown方法retrun了true导致</span></span><br><span class="line">    <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_BACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion</span><br><span class="line">                &gt;= Build.VERSION_CODES.ECLAIR) &#123;</span><br><span class="line">            event.startTracking();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onBackPressed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDefaultKeyMode == DEFAULT_KEYS_DISABLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT) &#123;</span><br><span class="line">        <span class="type">Window</span> <span class="variable">w</span> <span class="operator">=</span> getWindow();</span><br><span class="line">        <span class="keyword">if</span> (w.hasFeature(Window.FEATURE_OPTIONS_PANEL) &amp;&amp;</span><br><span class="line">                w.performPanelShortcut(Window.FEATURE_OPTIONS_PANEL, keyCode, event,</span><br><span class="line">                        Menu.FLAG_ALWAYS_PERFORM_CLOSE)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_TAB) &#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t consume TAB here since it&#x27;s used for navigation. Arrow keys</span></span><br><span class="line">        <span class="comment">// aren&#x27;t considered &quot;typing keys&quot; so they already won&#x27;t get consumed.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Common code for DEFAULT_KEYS_DIALER &amp; DEFAULT_KEYS_SEARCH_*</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">clearSpannable</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> handled;</span><br><span class="line">        <span class="keyword">if</span> ((event.getRepeatCount() != <span class="number">0</span>) || event.isSystem()) &#123;</span><br><span class="line">            clearSpannable = <span class="literal">true</span>;</span><br><span class="line">            handled = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = TextKeyListener.getInstance().onKeyDown(</span><br><span class="line">                    <span class="literal">null</span>, mDefaultKeySsb, keyCode, event);</span><br><span class="line">            <span class="keyword">if</span> (handled &amp;&amp; mDefaultKeySsb.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// something useable has been typed - dispatch it now.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> mDefaultKeySsb.toString();</span><br><span class="line">                clearSpannable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (mDefaultKeyMode) &#123;</span><br><span class="line">                <span class="keyword">case</span> DEFAULT_KEYS_DIALER:</span><br><span class="line">                    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_DIAL,  Uri.parse(<span class="string">&quot;tel:&quot;</span> + str));</span><br><span class="line">                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">                    startActivity(intent);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DEFAULT_KEYS_SEARCH_LOCAL:</span><br><span class="line">                    startSearch(str, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> DEFAULT_KEYS_SEARCH_GLOBAL:</span><br><span class="line">                    startSearch(str, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (clearSpannable) &#123;</span><br><span class="line">            mDefaultKeySsb.clear();</span><br><span class="line">            mDefaultKeySsb.clearSpans();</span><br><span class="line">            Selection.setSelection(mDefaultKeySsb,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到<code>Decorview</code>中的<code>dispatchKeyEvent</code>方法看看<code>PhoneWindow</code>的<code>onKeyDown</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A key was pressed down and not handled by anything else in the window.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #onKeyUp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> android.view.KeyEvent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">onKeyDown</span><span class="params">(<span class="type">int</span> featureId, <span class="type">int</span> keyCode, KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">/* ****************************************************************************</span></span><br><span class="line"><span class="comment">     * HOW TO DECIDE WHERE YOUR KEY HANDLING GOES.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If your key handling must happen before the app gets a crack at the event,</span></span><br><span class="line"><span class="comment">     * it goes in PhoneWindowManager.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If your key handling should happen in all windows, and does not depend on</span></span><br><span class="line"><span class="comment">     * the state of the current application, other than that the current</span></span><br><span class="line"><span class="comment">     * application can override the behavior by handling the event itself, it</span></span><br><span class="line"><span class="comment">     * should go in PhoneFallbackEventHandler.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Only if your handling depends on the window, and the fact that it has</span></span><br><span class="line"><span class="comment">     * a DecorView, should it go here.</span></span><br><span class="line"><span class="comment">     * ****************************************************************************/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> KeyEvent.<span class="type">DispatcherState</span> <span class="variable">dispatcher</span> <span class="operator">=</span></span><br><span class="line">            mDecor != <span class="literal">null</span> ? mDecor.getKeyDispatcherState() : <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//Log.i(TAG, &quot;Key down: repeat=&quot; + event.getRepeatCount()</span></span><br><span class="line">    <span class="comment">//        + &quot; flags=0x&quot; + Integer.toHexString(event.getFlags()));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (keyCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_VOLUME_UP:</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_VOLUME_DOWN:</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_VOLUME_MUTE: &#123;</span><br><span class="line">            <span class="comment">// If we have a session send it the volume command, otherwise</span></span><br><span class="line">            <span class="comment">// use the suggested stream.</span></span><br><span class="line">            <span class="keyword">if</span> (mMediaController != <span class="literal">null</span>) &#123;</span><br><span class="line">                mMediaController.dispatchVolumeButtonEventAsSystemService(event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                getMediaSessionManager().dispatchVolumeKeyEventAsSystemService(event,</span><br><span class="line">                        mVolumeControlStreamType);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// These are all the recognized media key codes in</span></span><br><span class="line">        <span class="comment">// KeyEvent.isMediaKey()</span></span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_PLAY:</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_PAUSE:</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_MUTE:</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_HEADSETHOOK:</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_STOP:</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_NEXT:</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_PREVIOUS:</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_REWIND:</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_RECORD:</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_FAST_FORWARD: &#123;</span><br><span class="line">            <span class="keyword">if</span> (mMediaController != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mMediaController.dispatchMediaButtonEventAsSystemService(event)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_MENU: &#123;</span><br><span class="line">            onKeyDownPanel((featureId &lt; <span class="number">0</span>) ? FEATURE_OPTIONS_PANEL : featureId, event);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_BACK: &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getRepeatCount() &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (featureId &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// Currently don&#x27;t do anything with long press.</span></span><br><span class="line">            <span class="keyword">if</span> (dispatcher != <span class="literal">null</span>) &#123;</span><br><span class="line">                dispatcher.startTracking(event, <span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>onKeyUp</code>方法也可以自己再看下，以上就是浅谈按键事件的分发流程了。</p>
<p>总结:</p>
<ul>
<li>按键的分发方向为<code>DecorView</code>——<code>Activity</code>——<code>ViewGroup</code>——<code>View</code></li>
<li>按键的消费方向<code>View</code>——<code>Activity</code>——<code>PhoneWindow</code></li>
<li>各种Callback接口的处理优先级低于监听器，也就是说各种<code>onXXXListener</code>的方法优先被调用</li>
</ul>
<h3 id="三、焦点导航流程"><a href="#三、焦点导航流程" class="headerlink" title="三、焦点导航流程"></a>三、焦点导航流程</h3><p>上面讲解了按键事件分发流程，当上面分发完所有都没消费的时候，就会继续走<code>ViewRootImpl</code>的焦点导航流程，接下来看下<code>performFocusNavigation</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">performFocusNavigation</span><span class="params">(KeyEvent event)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">direction</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  	<span class="comment">// 1.判断方向键上下左右和Tab键</span></span><br><span class="line">    <span class="keyword">switch</span> (event.getKeyCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_LEFT:</span><br><span class="line">            <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_LEFT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_RIGHT:</span><br><span class="line">            <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_RIGHT;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_UP:</span><br><span class="line">            <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_UP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_DOWN:</span><br><span class="line">            <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_DOWN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KeyEvent.KEYCODE_TAB:</span><br><span class="line">            <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                direction = View.FOCUS_FORWARD;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.hasModifiers(KeyEvent.META_SHIFT_ON)) &#123;</span><br><span class="line">                direction = View.FOCUS_BACKWARD;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (direction != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2.mView:即DecorView，DecorView是整个ViewTree的最顶层View，代表了整个应用的界面.</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">focused</span> <span class="operator">=</span> mView.findFocus();</span><br><span class="line">        <span class="keyword">if</span> (focused != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 3.找到了当前获得焦点的focused,调用该焦点view的focusSearch方法</span></span><br><span class="line">            <span class="type">View</span> <span class="variable">v</span> <span class="operator">=</span> focused.focusSearch(direction);</span><br><span class="line">            <span class="keyword">if</span> (v != <span class="literal">null</span> &amp;&amp; v != focused) &#123;</span><br><span class="line">                <span class="comment">// do the math the get the interesting rect</span></span><br><span class="line">                <span class="comment">// of previous focused into the coord system of</span></span><br><span class="line">                <span class="comment">// newly focused view</span></span><br><span class="line">                focused.getFocusedRect(mTempRect);</span><br><span class="line">                <span class="keyword">if</span> (mView <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">                    ((ViewGroup) mView).offsetDescendantRectToMyCoords(</span><br><span class="line">                            focused, mTempRect);</span><br><span class="line">                    ((ViewGroup) mView).offsetRectIntoDescendantCoords(</span><br><span class="line">                            v, mTempRect);</span><br><span class="line">                &#125;</span><br><span class="line">              	<span class="comment">// 4.找到的下一个可获取焦点的view不是当前已经获得焦点的view，则调用requestFocus方法</span></span><br><span class="line">                <span class="keyword">if</span> (v.requestFocus(direction, mTempRect)) &#123;</span><br><span class="line">                    playSoundEffect(SoundEffectConstants</span><br><span class="line">                            .getContantForFocusDirection(direction));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           	<span class="comment">// 5.给当前获取焦点的focused view 最后一次处理事件的机会</span></span><br><span class="line">            <span class="comment">// Give the focused view a last chance to handle the dpad key.</span></span><br><span class="line">            <span class="keyword">if</span> (mView.dispatchUnhandledMove(focused, direction)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 6.递归调用，重置默认焦点（整个视图树上只能有唯一一个默认焦点view）</span></span><br><span class="line">            <span class="keyword">if</span> (mView.restoreDefaultFocus()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="findFocus"><a href="#findFocus" class="headerlink" title="findFocus"></a>findFocus</h4><p>首先我们看<code>mView.findFocus()</code>，该方法实际是调用了<code>ViewGroup</code>的<code>findFocus</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (non-Javadoc)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see android.view.View#findFocus()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">findFocus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Find focus in &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;: flags=&quot;</span></span><br><span class="line">                + isFocused() + <span class="string">&quot;, child=&quot;</span> + mFocused);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFocused()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFocused != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mFocused.findFocus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="focusSearch"><a href="#focusSearch" class="headerlink" title="focusSearch"></a>focusSearch</h4><p>该方法很简单，就是向下递归查找在当前页面已经获取焦点的<code>View</code>，继续看<code>focused.focusSearch(direction)</code>调用了<code>View</code>的<code>focusSearch</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find the nearest view in the specified direction that can take focus.</span></span><br><span class="line"><span class="comment"> * This does not actually give focus to that view.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The nearest focusable in the specified direction, or null if none</span></span><br><span class="line"><span class="comment"> *         can be found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">focusSearch</span><span class="params">(<span class="meta">@FocusRealDirection</span> <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mParent.focusSearch(<span class="built_in">this</span>, direction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法向上递归查找，调用<code>ViewGroup</code>的<code>focusSearch</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find the nearest view in the specified direction that wants to take</span></span><br><span class="line"><span class="comment"> * focus.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> focused The view that currently has focus</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and</span></span><br><span class="line"><span class="comment"> *        FOCUS_RIGHT, or 0 for not applicable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">focusSearch</span><span class="params">(View focused, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isRootNamespace()) &#123;</span><br><span class="line">        <span class="comment">// root namespace means we should consider ourselves the top of the</span></span><br><span class="line">        <span class="comment">// tree for focus searching; otherwise we could be focus searching</span></span><br><span class="line">        <span class="comment">// into other tabs.  see LocalActivityManager and TabHost for more info.</span></span><br><span class="line">        <span class="keyword">return</span> FocusFinder.getInstance().findNextFocus(<span class="built_in">this</span>, focused, direction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mParent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mParent.focusSearch(focused, direction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是根命名空间，则调用<code>FocusFinder</code>的<code>findNextFocus</code>方法查找焦点，否则继续往上查找。继续看<code>FocusFinder</code>的<code>findNextFocus</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find the next view to take focus in root&#x27;s descendants, starting from the view</span></span><br><span class="line"><span class="comment"> * that currently is focused.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root Contains focused. Cannot be null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> focused Has focus now.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> direction Direction to look.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The next focusable view, or null if none exists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title function_">findNextFocus</span><span class="params">(ViewGroup root, View focused, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> findNextFocus(root, focused, <span class="literal">null</span>, direction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> View <span class="title function_">findNextFocus</span><span class="params">(ViewGroup root, View focused, Rect focusedRect, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">    <span class="type">View</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ViewGroup</span> <span class="variable">effectiveRoot</span> <span class="operator">=</span> getEffectiveRoot(root, focused);</span><br><span class="line">    <span class="keyword">if</span> (focused != <span class="literal">null</span>) &#123;</span><br><span class="line">      	<span class="comment">// 1.查找用户指定的获取下一个焦点的view</span></span><br><span class="line">        next = findNextUserSpecifiedFocus(effectiveRoot, focused, direction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">      	<span class="comment">// 2.如果找到用户指定的焦点，则直接返回该焦点</span></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;View&gt; focusables = mTempList;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        focusables.clear();</span><br><span class="line">        <span class="comment">// 3.添加effectiveRoot下的所有view到focusables集合中去，重写ViewGroup的该方法可以实现焦点记忆功能</span></span><br><span class="line">        effectiveRoot.addFocusables(focusables, direction);</span><br><span class="line">        <span class="keyword">if</span> (!focusables.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 4.根据系统默认的就近原则算法，查找下一个可获取焦点的最近的view</span></span><br><span class="line">            next = findNextFocus(effectiveRoot, focused, focusedRect, direction, focusables);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        focusables.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法首先查找用户指定的下一个获取焦点的<code>view</code>，如果找到了直接返回该<code>view</code>，如果没找到继续下面先添加<code>effectiveRoot</code>下的所有<code>view</code>到<code>focusables</code>集合中去，然后调用<code>findNextFocus</code>方法查找系统可获取下一个焦点的最近<code>view</code>。</p>
<h4 id="findNextUserSpecifiedFocus"><a href="#findNextUserSpecifiedFocus" class="headerlink" title="findNextUserSpecifiedFocus"></a>findNextUserSpecifiedFocus</h4><p>我们先看下<code>findNextUserSpecifiedFocus</code>方法的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> View <span class="title function_">findNextUserSpecifiedFocus</span><span class="params">(ViewGroup root, View focused, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">    <span class="comment">// check for user specified next focus</span></span><br><span class="line">    <span class="type">View</span> <span class="variable">userSetNextFocus</span> <span class="operator">=</span> focused.findUserSetNextFocus(root, direction);</span><br><span class="line">    <span class="type">View</span> <span class="variable">cycleCheck</span> <span class="operator">=</span> userSetNextFocus;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cycleStep</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// we want the first toggle to yield false</span></span><br><span class="line">    <span class="keyword">while</span> (userSetNextFocus != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userSetNextFocus.isFocusable()</span><br><span class="line">                &amp;&amp; userSetNextFocus.getVisibility() == View.VISIBLE</span><br><span class="line">                &amp;&amp; (!userSetNextFocus.isInTouchMode()</span><br><span class="line">                        || userSetNextFocus.isFocusableInTouchMode())) &#123;</span><br><span class="line">            <span class="keyword">return</span> userSetNextFocus;</span><br><span class="line">        &#125;</span><br><span class="line">        userSetNextFocus = userSetNextFocus.findUserSetNextFocus(root, direction);</span><br><span class="line">        <span class="keyword">if</span> (cycleStep = !cycleStep) &#123;</span><br><span class="line">            cycleCheck = cycleCheck.findUserSetNextFocus(root, direction);</span><br><span class="line">            <span class="keyword">if</span> (cycleCheck == userSetNextFocus) &#123;</span><br><span class="line">                <span class="comment">// found a cycle, user-specified focus forms a loop and none of the views</span></span><br><span class="line">                <span class="comment">// are currently focusable.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过用户指定焦点方式不是本篇的重点,这里就不贴出内部细节源码了。该方法实际就是调用<code>View</code>的<code>findUserSetNextFocus</code>方法来查找用户设置的下一个可获取焦点的<code>view</code>，然后在<code>while</code>循环中判断如果找到的是可以获取焦点并且可见的并且不是<code>InTouchNode</code>模式，则返回该焦点，否则继续循环查找直到找了一个循环没有找到可以获取焦点的或者<code>userSetNextFocus</code>为<code>null</code>跳出循环返回<code>null</code>。</p>
<h4 id="findNextFocus"><a href="#findNextFocus" class="headerlink" title="findNextFocus"></a>findNextFocus</h4><p>再来看下系统就近原则查找的<code>findNextFocus</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> View <span class="title function_">findNextFocus</span><span class="params">(ViewGroup root, View focused, Rect focusedRect,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> direction, ArrayList&lt;View&gt; focusables)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (focused != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (focusedRect == <span class="literal">null</span>) &#123;</span><br><span class="line">            focusedRect = mFocusedRect;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 1.给focusedRect赋值为已获取焦点的view视图的可见绘图边界</span></span><br><span class="line">        <span class="comment">// fill in interesting rect from focused</span></span><br><span class="line">        focused.getFocusedRect(focusedRect);</span><br><span class="line">        root.offsetDescendantRectToMyCoords(focused, focusedRect);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (focusedRect == <span class="literal">null</span>) &#123;</span><br><span class="line">            focusedRect = mFocusedRect;</span><br><span class="line">            <span class="comment">// make up a rect at top left or bottom right of root</span></span><br><span class="line">            <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">                <span class="keyword">case</span> View.FOCUS_RIGHT:</span><br><span class="line">                <span class="keyword">case</span> View.FOCUS_DOWN:</span><br><span class="line">                		<span class="comment">// 2.修改focusedRect左上角边界为root的左上角边缘</span></span><br><span class="line">                    setFocusTopLeft(root, focusedRect);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> View.FOCUS_FORWARD:</span><br><span class="line">                    <span class="keyword">if</span> (root.isLayoutRtl()) &#123;</span><br><span class="line">                        setFocusBottomRight(root, focusedRect);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        setFocusTopLeft(root, focusedRect);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> View.FOCUS_LEFT:</span><br><span class="line">                <span class="keyword">case</span> View.FOCUS_UP:</span><br><span class="line">                		<span class="comment">// 3.修改focusedRect右下角边界为root的右下角边缘</span></span><br><span class="line">                    setFocusBottomRight(root, focusedRect);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> View.FOCUS_BACKWARD:</span><br><span class="line">                    <span class="keyword">if</span> (root.isLayoutRtl()) &#123;</span><br><span class="line">                        setFocusTopLeft(root, focusedRect);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        setFocusBottomRight(root, focusedRect);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_FORWARD:</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_BACKWARD:</span><br><span class="line">        		<span class="comment">// 4.在相对方向上找到下一个焦点</span></span><br><span class="line">            <span class="keyword">return</span> findNextFocusInRelativeDirection(focusables, root, focused, focusedRect,</span><br><span class="line">                    direction);</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_UP:</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_DOWN:</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_LEFT:</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_RIGHT:</span><br><span class="line">           	<span class="comment">// 5.在绝对相对方向上找到下一个焦点</span></span><br><span class="line">            <span class="keyword">return</span> findNextFocusInAbsoluteDirection(focusables, root, focused,</span><br><span class="line">                    focusedRect, direction);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown direction: &quot;</span> + direction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法主要通过<code>findNextFocusInRelativeDirection</code>在相对方向上找下一个焦点，该方法内部逻辑比较简单，这里就不贴出来了，进去看下就知道其实就是先给<code>focusables</code>排序，然后从中找到<code>focused</code>在其中的后一个或前一个<code>view</code>，如果没找到并且<code>focusables</code>不为空则返回<code>focusables</code>的第一个。</p>
<p>接下来我们重点看下<code>findNextFocusInAbsoluteDirection</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">View <span class="title function_">findNextFocusInAbsoluteDirection</span><span class="params">(ArrayList&lt;View&gt; focusables, ViewGroup root, View focused,</span></span><br><span class="line"><span class="params">        Rect focusedRect, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">    <span class="comment">// initialize the best candidate to something impossible</span></span><br><span class="line">    <span class="comment">// (so the first plausible view will become the best choice)</span></span><br><span class="line">    mBestCandidateRect.set(focusedRect);</span><br><span class="line">    <span class="keyword">switch</span>(direction) &#123;</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_LEFT:</span><br><span class="line">            mBestCandidateRect.offset(focusedRect.width() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_RIGHT:</span><br><span class="line">            mBestCandidateRect.offset(-(focusedRect.width() + <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_UP:</span><br><span class="line">            mBestCandidateRect.offset(<span class="number">0</span>, focusedRect.height() + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_DOWN:</span><br><span class="line">            mBestCandidateRect.offset(<span class="number">0</span>, -(focusedRect.height() + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">View</span> <span class="variable">closest</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">numFocusables</span> <span class="operator">=</span> focusables.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numFocusables; i++) &#123;</span><br><span class="line">        <span class="type">View</span> <span class="variable">focusable</span> <span class="operator">=</span> focusables.get(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// only interested in other non-root views</span></span><br><span class="line">        <span class="keyword">if</span> (focusable == focused || focusable == root) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get focus bounds of other view in same coordinate system</span></span><br><span class="line">        focusable.getFocusedRect(mOtherRect);</span><br><span class="line">        root.offsetDescendantRectToMyCoords(focusable, mOtherRect);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isBetterCandidate(direction, focusedRect, mOtherRect, mBestCandidateRect)) &#123;</span><br><span class="line">            mBestCandidateRect.set(mOtherRect);</span><br><span class="line">            closest = focusable;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> closest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isBetterCandidate"><a href="#isBetterCandidate" class="headerlink" title="isBetterCandidate"></a>isBetterCandidate</h4><p>再看下<code>isBetterCandidate</code>方法，该方法很关键，内部包含一系列逻辑如何成为最佳候选者:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Is rect1 a better candidate than rect2 for a focus search in a particular</span></span><br><span class="line"><span class="comment"> * direction from a source rect?  This is the core routine that determines</span></span><br><span class="line"><span class="comment"> * the order of focus searching.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> direction the direction (up, down, left, right)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source The source we are searching from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rect1 The candidate rectangle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rect2 The current best candidate.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Whether the candidate is the new best.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isBetterCandidate</span><span class="params">(<span class="type">int</span> direction, Rect source, Rect rect1, Rect rect2)</span> &#123;</span><br><span class="line"></span><br><span class="line"> 	  <span class="comment">// 1.source = focusedRect；rect1 = mOtherRect；rect2 = mBestCandidateRect</span></span><br><span class="line">    <span class="comment">// 以向左寻焦为例,判断rect1是否右边在source右边的左侧并且rect1的左边在source左边的左侧</span></span><br><span class="line">    <span class="comment">// to be a better candidate, need to at least be a candidate in the first</span></span><br><span class="line">    <span class="comment">// place :)</span></span><br><span class="line">    <span class="keyword">if</span> (!isCandidate(source, rect1, direction)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 2.判断react2是否在source左边，如果不是则选择react1，如果是继续下面判断</span></span><br><span class="line">    <span class="comment">// we know that rect1 is a candidate.. if rect2 is not a candidate,</span></span><br><span class="line">    <span class="comment">// rect1 is better</span></span><br><span class="line">    <span class="keyword">if</span> (!isCandidate(source, rect2, direction)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 3.根据方向上是否重叠和距离判断谁更合适</span></span><br><span class="line">    <span class="comment">// if rect1 is better by beam, it wins</span></span><br><span class="line">    <span class="keyword">if</span> (beamBeats(direction, source, rect1, rect2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 4.交换react1和react1继续比较</span></span><br><span class="line">    <span class="comment">// if rect2 is better, then rect1 cant&#x27; be :)</span></span><br><span class="line">    <span class="keyword">if</span> (beamBeats(direction, source, rect2, rect1)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 5.否则，继续比较距离</span></span><br><span class="line">    <span class="comment">// otherwise, do fudge-tastic comparison of the major and minor axis</span></span><br><span class="line">    <span class="keyword">return</span> (getWeightedDistanceFor(</span><br><span class="line">                    majorAxisDistance(direction, source, rect1),</span><br><span class="line">                    minorAxisDistance(direction, source, rect1))</span><br><span class="line">            &lt; getWeightedDistanceFor(</span><br><span class="line">                    majorAxisDistance(direction, source, rect2),</span><br><span class="line">                    minorAxisDistance(direction, source, rect2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法英文注释很直观，就不中文翻译了，首先看下成为候选人的<code>isCandidate</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Is destRect a candidate for the next focus given the direction?  This</span></span><br><span class="line"><span class="comment"> * checks whether the dest is at least partially to the direction of (e.g left of)</span></span><br><span class="line"><span class="comment"> * from source.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Includes an edge case for an empty rect (which is used in some cases when</span></span><br><span class="line"><span class="comment"> * searching from a point on the screen).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCandidate</span><span class="params">(Rect srcRect, Rect destRect, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_LEFT:</span><br><span class="line">            <span class="keyword">return</span> (srcRect.right &gt; destRect.right || srcRect.left &gt;= destRect.right) </span><br><span class="line">                    &amp;&amp; srcRect.left &gt; destRect.left;</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_RIGHT:</span><br><span class="line">            <span class="keyword">return</span> (srcRect.left &lt; destRect.left || srcRect.right &lt;= destRect.left)</span><br><span class="line">                    &amp;&amp; srcRect.right &lt; destRect.right;</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_UP:</span><br><span class="line">            <span class="keyword">return</span> (srcRect.bottom &gt; destRect.bottom || srcRect.top &gt;= destRect.bottom)</span><br><span class="line">                    &amp;&amp; srcRect.top &gt; destRect.top;</span><br><span class="line">        <span class="keyword">case</span> View.FOCUS_DOWN:</span><br><span class="line">            <span class="keyword">return</span> (srcRect.top &lt; destRect.top || srcRect.bottom &lt;= destRect.top)</span><br><span class="line">                    &amp;&amp; srcRect.bottom &lt; destRect.bottom;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;direction must be one of &quot;</span></span><br><span class="line">            + <span class="string">&quot;&#123;FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, FOCUS_RIGHT&#125;.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法判断了目标Rect如果在源Rect的方向一侧且不在内部的话，则为候选者，如第一个<code>destRect</code>左侧应在<code>srcRect</code>左侧左边，<code>destRect</code>右侧应在<code>srcRect</code>右侧左边，其他方向同理。</p>
<p>接下来看下<code>beamBeats</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * One rectangle may be another candidate than another by virtue of being</span></span><br><span class="line"><span class="comment"> * exclusively in the beam of the source rect.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Whether rect1 is a better candidate than rect2 by virtue of it being in src&#x27;s</span></span><br><span class="line"><span class="comment"> *      beam</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">beamBeats</span><span class="params">(<span class="type">int</span> direction, Rect source, Rect rect1, Rect rect2)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">rect1InSrcBeam</span> <span class="operator">=</span> beamsOverlap(direction, source, rect1);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">rect2InSrcBeam</span> <span class="operator">=</span> beamsOverlap(direction, source, rect2);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 1.还是以左为例子，如果rect2在垂直方向重合或者rect1垂直方向不重合，则rect1不比rect2合适</span></span><br><span class="line">    <span class="comment">// if rect1 isn&#x27;t exclusively in the src beam, it doesn&#x27;t win</span></span><br><span class="line">    <span class="keyword">if</span> (rect2InSrcBeam || !rect1InSrcBeam) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we know rect1 is in the beam, and rect2 is not</span></span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 2.source不在rect2的左边</span></span><br><span class="line">    <span class="comment">// if rect1 is to the direction of, and rect2 is not, rect1 wins.</span></span><br><span class="line">    <span class="comment">// for example, for direction left, if rect1 is to the left of the source</span></span><br><span class="line">    <span class="comment">// and rect2 is below, then we always prefer the in beam rect1, since rect2</span></span><br><span class="line">    <span class="comment">// could be reached by going down.</span></span><br><span class="line">    <span class="keyword">if</span> (!isToDirectionOf(direction, source, rect2)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">// 3.如果是左右方向，则react1更合适</span></span><br><span class="line">    <span class="comment">// for horizontal directions, being exclusively in beam always wins</span></span><br><span class="line">    <span class="keyword">if</span> ((direction == View.FOCUS_LEFT || direction == View.FOCUS_RIGHT)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 4.以按下键为例，如果rect1顶部到source底部的距离小于rect2底部到source底部到距离，则rect1更合适</span></span><br><span class="line">    <span class="comment">// for vertical directions, beams only beat up to a point:</span></span><br><span class="line">    <span class="comment">// now, as long as rect2 isn&#x27;t completely closer, rect1 wins</span></span><br><span class="line">    <span class="comment">// e.g for direction down, completely closer means for rect2&#x27;s top</span></span><br><span class="line">    <span class="comment">// edge to be closer to the source&#x27;s top edge than rect1&#x27;s bottom edge.</span></span><br><span class="line">    <span class="keyword">return</span> (majorAxisDistance(direction, source, rect1)</span><br><span class="line">            &lt; majorAxisDistanceToFarEdge(direction, source, rect2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法根据重叠和水平方向以及垂直距离判断谁更合适，接下来看下上面<code>isBetterCandidate</code>方法中的<code>getWeightedDistanceFor</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fudge-factor opportunity: how to calculate distance given major and minor</span></span><br><span class="line"><span class="comment"> * axis distances.  Warning: this fudge factor is finely tuned, be sure to</span></span><br><span class="line"><span class="comment"> * run all focus tests if you dare tweak it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">getWeightedDistanceFor</span><span class="params">(<span class="type">long</span> majorAxisDistance, <span class="type">long</span> minorAxisDistance)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">13</span> * majorAxisDistance * majorAxisDistance</span><br><span class="line">            + minorAxisDistance * minorAxisDistance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法就是返回自定义的一个数学公式的值，<code>majorAxisDistance</code>方法主要是计算当前焦点区域(src)到候选区域(dest)在目标方向上较近的那条边界的距离，<code>majorAxisDistanceToFarEdge</code>方法主要是 计算当前焦点区域(src)到候选区域(dest)在目标方向上较远的那条边界的距离。</p>
<p>而最上面的<code>minorAxisDistance</code>方法主要是计算当前获焦区域(src)中心点到候选区域(dest)中心点非目标方向上的距离。</p>
<h4 id="requestFocus"><a href="#requestFocus" class="headerlink" title="requestFocus"></a>requestFocus</h4><p>接着我们再来看下最开始找到可以获取的焦点后执行的请求焦点的方法<code>requestFocus</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call this to try to give focus to a specific view or to one of its descendants</span></span><br><span class="line"><span class="comment"> * and give it hints about the direction and a specific rectangle that the focus</span></span><br><span class="line"><span class="comment"> * is coming from.  The rectangle can help give larger views a finer grained hint</span></span><br><span class="line"><span class="comment"> * about where focus is coming from, and therefore, where to show selection, or</span></span><br><span class="line"><span class="comment"> * forward focus change internally.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A view will not actually take focus if it is not focusable (&#123;<span class="doctag">@link</span> #isFocusable&#125; returns</span></span><br><span class="line"><span class="comment"> * false), or if it is focusable and it is not focusable in touch mode</span></span><br><span class="line"><span class="comment"> * (&#123;<span class="doctag">@link</span> #isFocusableInTouchMode&#125;) while the device is in touch mode.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A View will not take focus if it is not visible.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A View will not take focus if one of its parents has</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> android.view.ViewGroup#getDescendantFocusability()&#125; equal to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ViewGroup#FOCUS_BLOCK_DESCENDANTS&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See also &#123;<span class="doctag">@link</span> #focusSearch(int)&#125;, which is what you call to say that you</span></span><br><span class="line"><span class="comment"> * have focus, and you want your parent to look for the next one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You may wish to override this method if your custom &#123;<span class="doctag">@link</span> View&#125; has an internal</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> View&#125; that it wishes to forward the request to.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> direction One of FOCUS_UP, FOCUS_DOWN, FOCUS_LEFT, and FOCUS_RIGHT</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> previouslyFocusedRect The rectangle (in this View&#x27;s coordinate system)</span></span><br><span class="line"><span class="comment"> *        to give a finer grained hint about where focus is coming from.  May be null</span></span><br><span class="line"><span class="comment"> *        if there is no hint.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Whether this view or one of its descendants actually took focus.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">requestFocus</span><span class="params">(<span class="type">int</span> direction, Rect previouslyFocusedRect)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> requestFocusNoSearch(direction, previouslyFocusedRect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法又回调用<code>requestFocus</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">requestFocusNoSearch</span><span class="params">(<span class="type">int</span> direction, Rect previouslyFocusedRect)</span> &#123;</span><br><span class="line">    <span class="comment">// need to be focusable</span></span><br><span class="line">    <span class="keyword">if</span> (!canTakeFocus()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// need to be focusable in touch mode if in touch mode</span></span><br><span class="line">    <span class="keyword">if</span> (isInTouchMode() &amp;&amp;</span><br><span class="line">        (FOCUSABLE_IN_TOUCH_MODE != (mViewFlags &amp; FOCUSABLE_IN_TOUCH_MODE))) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// need to not have any parents blocking us</span></span><br><span class="line">    <span class="keyword">if</span> (hasAncestorThatBlocksDescendantFocus()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isLayoutValid()) &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_WANTS_FOCUS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearParentsWantFocus();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleFocusGainInternal(direction, previouslyFocusedRect);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法判断了如果不是可获焦的或者触摸屏没有设置<code>FOCUSABLE_IN_TOUCH_MODE</code>属性则返回<code>false</code>不往下执行，如果父<code>ViewGroup</code>设置了屏蔽子<code>View</code>获取焦点则也返回false，再看下最后的<code>handleFocusGainInternal</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Give this view focus. This will cause</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #onFocusChanged(boolean, int, android.graphics.Rect)&#125; to be called.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: this does not check whether this &#123;<span class="doctag">@link</span> View&#125; should get focus, it just</span></span><br><span class="line"><span class="comment"> * gives it focus no matter what.  It should only be called internally by framework</span></span><br><span class="line"><span class="comment"> * code that knows what it is doing, namely &#123;<span class="doctag">@link</span> #requestFocus(int, Rect)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> direction values are &#123;<span class="doctag">@link</span> View#FOCUS_UP&#125;, &#123;<span class="doctag">@link</span> View#FOCUS_DOWN&#125;,</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> View#FOCUS_LEFT&#125; or &#123;<span class="doctag">@link</span> View#FOCUS_RIGHT&#125;. This is the direction which</span></span><br><span class="line"><span class="comment"> *        focus moved when requestFocus() is called. It may not always</span></span><br><span class="line"><span class="comment"> *        apply, in which case use the default View.FOCUS_DOWN.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> previouslyFocusedRect The rectangle of the view that had focus</span></span><br><span class="line"><span class="comment"> *        prior in this View&#x27;s coordinate system.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">handleFocusGainInternal</span><span class="params">(<span class="meta">@FocusRealDirection</span> <span class="type">int</span> direction, Rect previouslyFocusedRect)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span> + <span class="string">&quot; requestFocus()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_FOCUSED) == <span class="number">0</span>) &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_FOCUSED;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 1.在根View寻找旧的已经获取焦点的view</span></span><br><span class="line">        <span class="type">View</span> <span class="variable">oldFocus</span> <span class="operator">=</span> (mAttachInfo != <span class="literal">null</span>) ? getRootView().findFocus() : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">     		<span class="comment">// 2.调用父控件中的requestChildFocus方法</span></span><br><span class="line">        <span class="keyword">if</span> (mParent != <span class="literal">null</span>) &#123;</span><br><span class="line">            mParent.requestChildFocus(<span class="built_in">this</span>, <span class="built_in">this</span>);</span><br><span class="line">            updateFocusedInCluster(oldFocus, direction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.调用ViewTreeObserver的分发焦点改变监听，旧的已经获取焦点的view和当前的view</span></span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnGlobalFocusChange(oldFocus, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.调用view的onFocusChanged回调</span></span><br><span class="line">        onFocusChanged(<span class="literal">true</span>, direction, previouslyFocusedRect);</span><br><span class="line">        refreshDrawableState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到该方法首先获取已经获取焦点的view，然后调用父控件的请求焦点方法，再分别通知设置的两个监听，最后刷新<code>Drawable</code>的状态，接着看下<code>ViewGroup</code>中的<code>requestChildFocus</code>方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestChildFocus</span><span class="params">(View child, View focused)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span> + <span class="string">&quot; requestChildFocus()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="comment">// 1.如果有设置屏蔽子控件获取焦点,则return</span></span><br><span class="line">    <span class="keyword">if</span> (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unfocus us, if necessary</span></span><br><span class="line">    <span class="built_in">super</span>.unFocus(focused);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.如果已经获取焦点的mFocused不是传进来的child，则清除掉mFocused的Focus状态，并且把child赋给mFocused</span></span><br><span class="line">    <span class="comment">// We had a previous notion of who had focus. Clear it.</span></span><br><span class="line">    <span class="keyword">if</span> (mFocused != child) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFocused != <span class="literal">null</span>) &#123;</span><br><span class="line">            mFocused.unFocus(focused);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFocused = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="literal">null</span>) &#123;</span><br><span class="line">        mParent.requestChildFocus(<span class="built_in">this</span>, focused);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法判断如果没有给<code>ViewGroup</code>设置<code>FOCUS_BLOCK_DESCENDANTS</code>属性则往下，如果已经获取焦点的<code>mFocused</code>不是传进来的<code>child</code>,则清除<code>mFocused</code>的<code>focus</code>状态,并且把<code>child</code>赋给<code>mFocused</code>即让&#96;&#96;child&#96;获取了焦点。</p>
<p>到此，<code>Android TV</code>按键焦点原理分析完了，学完本篇再回头看看开篇的问题你是否有了更深的理解了呢?</p>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b7f33f46d33c">View·InputEvent事件投递源码分析（一）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0f0406da935f/">Android 按键的焦点分发处理机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b59b0ff55030">Android TV 按键焦点事件分发流程详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/73e33ba10f5d">Android TV FocusFinder寻焦流程分析(二)</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6871542178506604551">Android焦点搜索过程解析</a></li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Android%E6%BA%90%E7%A0%81/">Android源码</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Android/">Android</a><a href="/tags/原理/">原理</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	<div class="share-jiathis">
	  
<div class="jiathis_style_24x24">
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_googleplus"></a>
	<a class="jiathis_button_douban"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
    var jiathis_config={
    data_track_clickback:true,
    sm:"copy,renren,cqq",
    pic:"",
    summary:"",
    
  </script> 
<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=
2049638" charset="utf-8"></script>      

	 </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2024/11/24/Harmony多目标产物方案/" title="Harmony多目标产物方案">
  <strong>上一篇：</strong><br/>
  <span>
  Harmony多目标产物方案</span>
</a>
</div>


<div class="next">
<a href="/2020/07/15/Xposed系列之微信屏蔽拍一拍(三)/"  title="Xposed系列之微信屏蔽拍一拍(三)">
 <strong>下一篇：</strong><br/> 
 <span>Xposed系列之微信屏蔽拍一拍(三)
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2022/06/22/Android-TV按键焦点原理浅谈/" data-title="Android TV按键焦点原理浅谈" data-url="http://yoursite.com/2022/06/22/Android-TV%E6%8C%89%E9%94%AE%E7%84%A6%E7%82%B9%E5%8E%9F%E7%90%86%E6%B5%85%E8%B0%88/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E5%85%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">一、按键事件入口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">二、按键事件分发流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%84%A6%E7%82%B9%E5%AF%BC%E8%88%AA%E6%B5%81%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">三、焦点导航流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#findFocus"><span class="toc-number">3.1.</span> <span class="toc-text">findFocus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#focusSearch"><span class="toc-number">3.2.</span> <span class="toc-text">focusSearch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findNextUserSpecifiedFocus"><span class="toc-number">3.3.</span> <span class="toc-text">findNextUserSpecifiedFocus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findNextFocus"><span class="toc-number">3.4.</span> <span class="toc-text">findNextFocus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isBetterCandidate"><span class="toc-number">3.5.</span> <span class="toc-text">isBetterCandidate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#requestFocus"><span class="toc-number">3.6.</span> <span class="toc-text">requestFocus</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">4.</span> <span class="toc-text">参考链接</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/AI/" title="AI">AI<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android上传下载/" title="Android上传下载">Android上传下载<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android图片/" title="Android图片">Android图片<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android应用常用功能/" title="Android应用常用功能">Android应用常用功能<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android性能/" title="Android性能">Android性能<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android控件/" title="Android控件">Android控件<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android数据格式/" title="Android数据格式">Android数据格式<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android源码/" title="Android源码">Android源码<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android第三方SDK及框架/" title="Android第三方SDK及框架">Android第三方SDK及框架<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android线程/" title="Android线程">Android线程<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android网络编程/" title="Android网络编程">Android网络编程<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/Android逆向/" title="Android逆向">Android逆向<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Harmony/" title="Harmony">Harmony<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/PS/" title="PS">PS<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Web/" title="Web">Web<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/自动化/" title="自动化">自动化<sup>2</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Android/" title="Android">Android<sup>33</sup></a></li>
			
		
			
				<li><a href="/tags/网络编程/" title="网络编程">网络编程<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/UI设计/" title="UI设计">UI设计<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/数据格式/" title="数据格式">数据格式<sup>8</sup></a></li>
			
		
			
				<li><a href="/tags/AI/" title="AI">AI<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/控件/" title="控件">控件<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Xposed/" title="Xposed">Xposed<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/逆向/" title="逆向">逆向<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/PS/" title="PS">PS<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/推送/" title="推送">推送<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/线程/" title="线程">线程<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/HTTP/" title="HTTP">HTTP<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Socket/" title="Socket">Socket<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/抓包/" title="抓包">抓包<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/WCF/" title="WCF">WCF<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/原理/" title="原理">原理<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/性能/" title="性能">性能<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/自动化/" title="自动化">自动化<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Harmony/" title="Harmony">Harmony<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://zjbztianya.github.io/" target="_blank" title="仗剑奔走天涯">仗剑奔走天涯</a>
            
          </li>
        
          <li>
            
            	<a href="http://xbdcc.cn" target="_blank" title="小不点">小不点</a>
            
          </li>
        
          <li>
            
            	<a href="http://mkblog.cn/" target="_blank" title="孟坤博客">孟坤博客</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Carlos. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/xiaobudian1994" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		<a href="https://www.douban.com/people/xbdcc" target="_blank" class="icon-douban" title="豆瓣"></a>
		
		
		
		
		<a href="mailto:363465939@qq.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2024 
		
		<a href="/me" target="_blank" title="Carlos">Carlos</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>




<script type="text/javascript">
  var duoshuoQuery = {short_name:"xbdcc"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->


  </body>
</html>
